"""Entities for the Video Processor Domain."""

from datetime import datetime, timezone
from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field, PrivateAttr

from .events import (
    DomainEvent,
    VideoProcessedEvent,
    VideoProcessingFailedEvent,
    VideoProcessingStartedEvent,
)
from .exceptions import InvalidStatusTransitionError
from .value_objects import VideoProcessingStatus


class Video(BaseModel):
    """Entity representing a Video in the processing system"""

    _events: list[DomainEvent] = PrivateAttr(
        default_factory=list,
    )  # List of domain events generated by this entity.

    _status: VideoProcessingStatus = PrivateAttr(
        VideoProcessingStatus.PENDING,
    )  # The processing status of the video.

    _processing_started_at: datetime | None = PrivateAttr(
        None,
    )  # The timestamp when the video processing started.

    _processed_at: datetime | None = PrivateAttr(
        None,
    )  # The timestamp when the video was processed.

    _failed_at: datetime | None = PrivateAttr(
        None,
    )  # The timestamp when the video processing failed.

    model_config = ConfigDict(from_attributes=True)

    video_id: UUID = Field(
        ..., description="Unique identifier for the processed video.", frozen=True
    )

    upload_path: str = Field(
        ...,
        description="The path in the storage where the video is uploaded.",
        frozen=True,
    )

    @property
    def output_path(self) -> str:
        """Get the output path where processed frames will be stored."""
        return f"{self.video_id}.zip"

    @property
    def status(self) -> VideoProcessingStatus:
        """Get the current processing status of the video."""
        return self._status

    @property
    def processing_started_at(self) -> datetime | None:
        """Get the timestamp when processing started."""
        return self._processing_started_at

    @property
    def processed_at(self) -> datetime | None:
        """Get the timestamp when processing completed."""
        return self._processed_at

    @property
    def failed_at(self) -> datetime | None:
        """Get the timestamp when processing failed."""
        return self._failed_at

    def start_processing(self) -> None:
        """Set the video status to PROCESSING."""

        if self._status != VideoProcessingStatus.PENDING:
            raise InvalidStatusTransitionError(
                self.video_id, self._status, VideoProcessingStatus.PROCESSING
            )

        self._status = VideoProcessingStatus.PROCESSING
        self._processing_started_at = datetime.now(timezone.utc)
        self._events.append(
            VideoProcessingStartedEvent(
                video_id=self.video_id,
                processing_started_at=self._processing_started_at,
            )
        )

    def complete_processing(self) -> None:
        """Set the video status to COMPLETED."""

        if self._status != VideoProcessingStatus.PROCESSING:
            raise InvalidStatusTransitionError(
                self.video_id, self._status, VideoProcessingStatus.COMPLETED
            )

        self._status = VideoProcessingStatus.COMPLETED
        self._processed_at = datetime.now(timezone.utc)
        self._events.append(
            VideoProcessedEvent(
                video_id=self.video_id,
                output_path=self.output_path,
                processed_at=self._processed_at,
            )
        )

    def fail_processing(self, error_message: str) -> None:
        """Set the video status to FAILED."""

        if self._status != VideoProcessingStatus.PROCESSING:
            raise InvalidStatusTransitionError(
                self.video_id, self._status, VideoProcessingStatus.FAILED
            )

        self._status = VideoProcessingStatus.FAILED
        self._failed_at = datetime.now(timezone.utc)
        self._events.append(
            VideoProcessingFailedEvent(
                video_id=self.video_id,
                failed_at=self._failed_at,
                error_message=error_message,
            )
        )

    def collect_events(self) -> list[DomainEvent]:
        """Collect and clear the domain events generated by this entity.

        Returns:
            list[DomainEvent]: The list of collected domain events.
        """
        events = self._events.copy()
        self._events.clear()
        return events
